この記事は [**LipersInSlums Advent Calendar 2023** _スラム社会実装の理論と実践〜もうみんな苦しんでる。苦しんでないのはおまえだけ〜_](https://adventar.org/calendars/9461) の xxx 日目の記事です。

前日の記事は yyy さんの xxx です。

皆さんは2023年もReactで苦しんだわけですが、一番苦しんだことといえばやっぱり非同期処理ではないでしょうか？

優秀なJSON色付け係である皆さんは当然ウェブフロントエンドを作成する際、APIから何かを取ってきて画面に表示するという処理を無限回（高々有限）書かされるわけですが、今日は[そんな皆様のために～](https://www.nicovideo.jp/watch/sm9720246)、  
**React 上でいい感じに非同期処理と付き合い、そして和解するためのテクニック** を紹介します。

# React と非同期処理のつらみ

なぜ React 上で非同期処理を扱うのはつらいのでしょうか？

それは React の設計思想との相性の悪さにあります。

React は、データから ReactNode を返す **関数** のような存在であるにも関わらず、ここに非同期処理が絡まってくると突然**副作用を考慮しなければならなくなるからです。**

例えば、JSON色付け係の嗜みである WebAPI からのデータを表示するような処理では

データフェッチ開始 → 待機 → 表示 (エラーが発生した場合はエラー表示)

と、1つのデータを表示するために3つ（エラー表示も含めれば4つ！）もの状態を考える必要があるのです。

しかし考えてみてください、JavaScript にはもともと Promise という、非同期処理のための便利な概念が存在しているはずです。

にもかかわらず、これを React 上で表現しようとすると、これらをわざわざ分解して表現する苦行を強いられることになります。  
加えて実際には単体のコンポーネントで処理が完結することはなく、取得したデータを更に以下のように props で渡したりしているうちに以下のようなコードになるのではないでしょうか。

```tsx

function FxxkingUserContainer() {
  const [data, setData] = useState<User>(null);

  useEffect(() => {
    (async () => {
      const res = await fetch("/api/sit/user");
      setData(await res.json());
    })();
  }, []);


  return data == null ? (
    <div>loading...</div>
  ) : (
    <FuxxkingUserProfile user={data} />
  );
}

```

具合が悪くなってきましたか？なってきたと思います。僕も書いていて手が震えてきました。  
ただでさえ非同期処理で嫌な気持ちになっているところにさらに **propsバケツリレー** をさせられるわけです。  
propsバケツリレーは **データがどこから来ているか、誰がどのデータに依存しているかが分からなくなるため、以後の開発体験を急速に悪化させます。**

とても人間的な所業とは思えません。

出来れば **同期処理と同じように** 以下のような形で、 **欲しいデータはコンポーネント自身で取得するように** 書きたいと思いませんか？

```tsx
function FxxkingUser() {
  const [data] = useSomethingAsyncStore(...);

  return <div>...</div>
}

```

見ているだけで吐き気を催す邪悪な先程のコードと比べ、こちらはいくらか見慣れた形になりました。

この形であれば先程の「非同期処理を意識した条件分岐」と「コンポーネントへデータをバケツリレーする」という邪悪な点を滅ぼすことが出来ます。

(なお、React hooks 自体がキモいと感じる人類は2020年までに絶滅し、一説には Svelte や Vue.js などに移ったと言われています)(妥当だと思います)(ちなみに冗談です)

しかし、果たしてこんなことが可能なのでしょうか？

安心してください、こういった **Render-as-You-Fetch** パターンを実現可能にするライブラリは意外とたくさんあります。やはり人類はみんな React でJSONに色付けさせられているんだなぁと思わざるを得ません。  
そして、それらは React 本体の `Suspense` との組み合わせで絶大な効果を発揮します。

なお、Suspense が React 本体に入ってから実はもう3年以上経つ(エビデンスは調べるのがめんどいので各自で調べて)ので、そろそろ「知らない人のために～」なんていう解説は省略します。

というわけで以上の点を前提として、この記事ではこの点をさらに深掘りしていきます。

# Suspense を前提としたデータ/コンポーネント設計をする

さて、それでは前述のようなコーディングスタイルを実現するためにはどういった設計を心掛け、またどういったライブラリを使うのがよいのでしょうか。

本来であれば **そういうライブラリを作ってみたｗ！** というのがアドカレにおける正しい仕草なのでしょうが、残念ながら執筆時間の都合で本記事では既存のライブラリを扱います。

というわけで散々引っ張りましたがここで Recoil の登場です。

https://recoiljs.org/

Recoil はいわゆる「状態管理ライブラリ」の一種ですが、非同期処理もある程度上手く扱える非常に柔軟なライブラリです。

また、このライブラリの特徴である「グローバルなデータを小さく扱うことが出来る」という点が、「コンポーネント自身で必要なデータを取得させる」という目的とよくマッチします。

何にせよ、まずは recoil の仕組みに非同期処理を乗せるためのコードを示します。

```ts

const userSelector = selector<User>({
  key: "user/userSelector",
  get: async () => {
    const res = fetch("...");
    return await res.json();
  }
});
```

selector は、値を加工して返す Store を定義するための機能です。  
recoil 公式では、 selector を **atom から取得したデータを何か加工して返す** というだけの存在としてかなりぞんざいに扱われている印象がありますが、実は以下のように非同期処理を行って何らかのデータを fetch するような例が紹介されています。

https://recoiljs.org/docs/guides/asynchronous-data-queries/#asynchronous-example

要はこの機能を存分に使っていこうということですが、これは実はかなり強力な仕組みです。

いちおうおさらいですが、この selector は以下のように使うことが出来ます。

```tsx

function FxxkingUser() {
  const user = useSelector(userSelector);

  return <div>...</div>
}

```

これはまさに、先ほどの **目指したい擬似コード** の形そのままではないでしょうか。  

このコンポーネントは、以下のように `Suspense` で囲うことで、非同期処理の途中である場合は `fallback` が表示されるようになります。

```tsx
<Suspense fallback={<div>loading...</div>}>
  <FxxkingUser />
</Suspense>
```

とはいえ、 Render-as-You-Fetch が実現出来るということは一体何を意味するのでしょうか？  
言い換えれば、Render-as-You-Fetch パターンに適したデータ設計とは一体どのようなものが考えられるでしょうか。

まず考えるのは、表示すべきデータを最小限の単位に分割出来ないかということです。  

例えばよくある従来のやり方では、User データを取得する際、以下のようにエンドポイントからこのような「ユーザーに関するすべてのデータ」が入ったJSONを取得する事が多いのではないでしょうか。

```ts



```

# TODO API 設計の話を書く

というわけで皆さんはこれで救われました。めでたしめでたし。  
明日の記事は・・・

「おい！ちょっと待ちやがれ！これだけじゃあリストを表示するときに下みてえなコードになるんじゃあねえかぁ？」

```tsx
function FxxkingUserList() {
  const userList = useSelector(userSelector);

  return <div>
    {userList.map(user => (
      <User user={user} />
    ))}
  </div>
}

```

「これじゃあ `userList` 以下のデータはまたpropsバケツリレーをしないといけなくなるじゃねえか！どこが救われてるんだ！クソクソ！！！」

そんなあなたのために、次は分割統治という考え方を紹介します。

dataloader の話

